var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var misc = require("./fs-misc");
var sources = require("./fs-sources");
var targets = require("./fs-targets");
var glob = require("./fs-glob");
var APromise = require("./promise");
var events = require("events");
var FileUtil = misc.FileUtil;
var Path = misc.Path;
var FileDataTarget = targets.FileDataTarget;
var StringDataTarget = targets.StringDataTarget;
var BufferDataTarget = targets.BufferDataTarget;
var FileDataSource = sources.FileDataSource;
var toDataSource = sources.toDataSource;
var EventEmitter = events.EventEmitter;
var search = glob.search;
var Promise = Promise || APromise;
var FilesystemPlus = (function (_super) {
    __extends(FilesystemPlus, _super);
    function FilesystemPlus(fs, local) {
        _super.call(this);
        this._fs = fs;
        this._local = local;
    }
    FilesystemPlus.prototype.open = function (path, flags, attrs, callback) {
        var _this = this;
        if (typeof callback === 'undefined' && typeof attrs === 'function') {
            callback = attrs;
            attrs = null;
        }
        return this._task(callback, function (callback) {
            _this._fs.open(path, flags, attrs, callback);
        });
    };
    FilesystemPlus.prototype.close = function (handle, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.close(handle, callback);
        });
    };
    FilesystemPlus.prototype.read = function (handle, buffer, offset, length, position, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.read(handle, buffer, offset, length, position, callback);
        });
    };
    FilesystemPlus.prototype.write = function (handle, buffer, offset, length, position, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.write(handle, buffer, offset, length, position, callback);
        });
    };
    FilesystemPlus.prototype.lstat = function (path, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.lstat(path, callback);
        });
    };
    FilesystemPlus.prototype.fstat = function (handle, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.fstat(handle, callback);
        });
    };
    FilesystemPlus.prototype.setstat = function (path, attrs, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.setstat(path, attrs, callback);
        });
    };
    FilesystemPlus.prototype.fsetstat = function (handle, attrs, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.fsetstat(handle, attrs, callback);
        });
    };
    FilesystemPlus.prototype.opendir = function (path, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.opendir(path, callback);
        });
    };
    FilesystemPlus.prototype.readdir = function (handle, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            if (typeof handle === 'string') {
                var path = Path.check(handle, 'path');
                var options = {
                    noglobstar: true,
                    nowildcard: true,
                    onedir: true,
                    dotdirs: true,
                    all: true
                };
                search(_this._fs, path, null, options, callback);
                return;
            }
            _this._fs.readdir(handle, callback);
        });
    };
    FilesystemPlus.prototype.unlink = function (path, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.unlink(path, callback);
        });
    };
    FilesystemPlus.prototype.mkdir = function (path, attrs, callback) {
        var _this = this;
        if (typeof callback === 'undefined' && typeof attrs === 'function') {
            callback = attrs;
            attrs = null;
        }
        return this._task(callback, function (callback) {
            _this._fs.mkdir(path, attrs, callback);
        });
    };
    FilesystemPlus.prototype.rmdir = function (path, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.rmdir(path, callback);
        });
    };
    FilesystemPlus.prototype.realpath = function (path, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.realpath(path, callback);
        });
    };
    FilesystemPlus.prototype.stat = function (path, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.stat(path, callback);
        });
    };
    FilesystemPlus.prototype.rename = function (oldPath, newPath, flags, callback) {
        var _this = this;
        if (typeof callback === 'undefined' && typeof flags === 'function') {
            callback = flags;
            flags = 0;
        }
        else {
            flags |= 0;
        }
        return this._task(callback, function (callback) {
            _this._fs.rename(oldPath, newPath, flags, callback);
        });
    };
    FilesystemPlus.prototype.readlink = function (path, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.readlink(path, callback);
        });
    };
    FilesystemPlus.prototype.symlink = function (oldPath, newPath, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.symlink(oldPath, newPath, callback);
        });
    };
    FilesystemPlus.prototype.join = function () {
        var paths = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            paths[_i - 0] = arguments[_i];
        }
        var path = new Path("", this._fs);
        return path.join.apply(path, arguments).normalize().path;
    };
    FilesystemPlus.prototype.link = function (oldPath, newPath, callback) {
        var _this = this;
        return this._task(callback, function (callback) {
            _this._fs.link(oldPath, newPath, callback);
        });
    };
    FilesystemPlus.prototype.list = function (remotePath, callback) {
        var _this = this;
        return this._task(callback, function (callback, emitter) {
            remotePath = Path.check(remotePath, 'remotePath');
            var options = {
                directories: true,
                files: true,
                nosort: false,
                dotdirs: false,
                noglobstar: true,
                onedir: true,
                all: true
            };
            search(_this._fs, remotePath, emitter, options, callback);
        });
    };
    FilesystemPlus.prototype.search = function (remotePath, options, callback) {
        var _this = this;
        if (typeof callback === 'undefined' && typeof options === 'function') {
            callback = options;
            options = null;
        }
        return this._task(callback, function (callback, emitter) {
            remotePath = Path.check(remotePath, 'remotePath');
            search(_this._fs, remotePath, emitter, options, callback);
        });
    };
    FilesystemPlus.prototype.info = function (remotePath, callback) {
        var _this = this;
        return this._task(callback, function (callback, emitter) {
            remotePath = Path.check(remotePath, 'remotePath');
            var options = {
                oneitem: true
            };
            search(_this._fs, remotePath, emitter, options, function (err, items) {
                if (err)
                    return callback(err, null);
                if (!items || items.length != 1)
                    return callback(new Error("Unexpected result"), null);
                callback(null, items[0]);
            });
        });
    };
    FilesystemPlus.prototype.readFile = function (remotePath, options, callback) {
        var _this = this;
        if (typeof callback === 'undefined' && typeof options === 'function') {
            callback = options;
            options = null;
        }
        return this._task(callback, function (callback, emitter) {
            var remote = Path.create(remotePath, _this._fs, 'remotePath');
            // process options
            options = options || {};
            var type = options.type;
            var encoding = options.encoding;
            if (type) {
                type = (type + "").toLowerCase();
                if (type == "string" || type == "text")
                    encoding = encoding || "utf8";
            }
            else {
                type = encoding ? "string" : "buffer";
            }
            // create appropriate target
            var target;
            switch (type) {
                case "text":
                case "string":
                    target = new StringDataTarget(encoding);
                    break;
                case "array":
                case "buffer":
                    target = new BufferDataTarget();
                    break;
                case "blob":
                // WEB: target = new BlobDataTarget(options.mimeType);
                // WEB: break;
                default:
                    throw new Error("Unsupported data kind: " + options.type);
            }
            // create source
            var source = new FileDataSource(remote.fs, remote.path);
            // copy file data
            FileUtil.copy(source, target, emitter, function (err) {
                if (err)
                    return callback(err, null);
                callback(null, target.result());
            });
        });
    };
    FilesystemPlus.prototype.putFile = function (localPath, remotePath, callback) {
        var _this = this;
        return this._task(callback, function (callback, emitter) {
            var local = Path.create(localPath, _this._local, 'localPath');
            var remote = Path.create(remotePath, _this._fs, 'remotePath');
            _this._copyFile(local, remote, emitter, callback);
        });
    };
    FilesystemPlus.prototype.getFile = function (remotePath, localPath, callback) {
        var _this = this;
        return this._task(callback, function (callback, emitter) {
            var remote = Path.create(remotePath, _this._fs, 'remotePath');
            var local = Path.create(localPath, _this._local, 'localPath');
            _this._copyFile(remote, local, emitter, callback);
        });
    };
    FilesystemPlus.prototype._copyFile = function (sourcePath, targetPath, emitter, callback) {
        // append filename if target path ens with slash
        if (targetPath.endsWithSlash()) {
            var filename = sourcePath.getName();
            targetPath = targetPath.join(filename);
        }
        // create source and target
        var source = new FileDataSource(sourcePath.fs, sourcePath.path);
        var target = new FileDataTarget(targetPath.fs, targetPath.path);
        // copy file data
        FileUtil.copy(source, target, emitter, function (err) { return callback(err); });
    };
    FilesystemPlus.prototype.upload = function (input, remotePath, callback) {
        var _this = this;
        return this._task(callback, function (callback, emitter) {
            var remote = Path.create(remotePath, _this._fs, 'remotePath');
            _this._copy(input, _this._local, remote, emitter, callback);
        });
    };
    FilesystemPlus.prototype.download = function (remotePath, localPath, callback) {
        var _this = this;
        return this._task(callback, function (callback, emitter) {
            var local = Path.create(localPath, _this._local, 'localPath');
            _this._copy(remotePath, _this._fs, local, emitter, callback);
        });
    };
    FilesystemPlus.prototype._copy = function (from, fromFs, toPath, emitter, callback) {
        var sources = null;
        var toFs = toPath.fs;
        toPath = toPath.removeTrailingSlash();
        toFs.stat(toPath.path, prepare);
        var directories = {};
        function prepare(err, stats) {
            if (err)
                return callback(err);
            if (!FileUtil.isDirectory(stats))
                return callback(new Error("Target path is not a directory"));
            try {
                toDataSource(fromFs, from, emitter, function (err, src) {
                    if (err)
                        return callback(err);
                    try {
                        sources = src;
                        sources.forEach(function (source) {
                            //TODO: calculate total size
                            //TODO: make sure that source.name is valid on target fs
                        });
                        next();
                    }
                    catch (err) {
                        callback(err);
                    }
                });
            }
            catch (err) {
                callback(err);
            }
        }
        function next() {
            var source = sources.shift();
            if (!source)
                return callback(null);
            var targetPath;
            if (typeof source.relativePath === "string") {
                var relativePath = new Path(source.relativePath, fromFs);
                targetPath = toPath.join(relativePath).normalize().path;
                checkParent(relativePath, transfer);
            }
            else {
                targetPath = toPath.join(source.name).path;
                transfer(null);
            }
            function transfer(err) {
                if (err)
                    return callback(err);
                if (FileUtil.isDirectory(source.stats)) {
                    FileUtil.mkdir(toFs, targetPath, transferred);
                }
                else {
                    var target = new FileDataTarget(toFs, targetPath);
                    FileUtil.copy(source, target, emitter, transferred);
                }
            }
            function transferred(err) {
                if (err)
                    return callback(err);
                next();
            }
        }
        function checkParent(path, callback) {
            var parent = path.getParent();
            if (parent.isTop())
                return callback(null);
            var exists = directories[parent];
            if (exists)
                return callback(null);
            checkParent(parent, function (err) {
                if (err)
                    return callback(err);
                try {
                    var targetPath = toPath.join(parent).path;
                    FileUtil.mkdir(toFs, targetPath, function (err) {
                        if (err)
                            return callback(err);
                        directories[parent] = true;
                        callback(null);
                    });
                }
                catch (err) {
                    callback(err);
                }
            });
        }
    };
    FilesystemPlus.prototype._task = function (callback, action) {
        var emitter;
        if (action.length >= 2)
            emitter = new EventEmitter();
        if (typeof callback === 'function') {
            action(callback, emitter);
            return emitter;
        }
        var promise = this._promise || Promise;
        var task = new promise(executor);
        task.on = on;
        task.once = once;
        return task;
        function on(event, listener) {
            if (emitter)
                emitter.on(event, listener);
            return task;
        }
        function once(event, listener) {
            if (emitter)
                emitter.on(event, listener);
            return task;
        }
        function executor(resolve, reject) {
            try {
                action(finish, emitter);
            }
            catch (err) {
                process.nextTick(function () { return finish(err); });
            }
            function finish() {
                var error = arguments[0];
                try {
                    if (error) {
                        if (emitter) {
                            var err = error;
                            if (EventEmitter.listenerCount(task, "error")) {
                                emitter.emit("error", err);
                                err = null;
                            }
                            emitter.emit("finish", err);
                        }
                        reject(error);
                    }
                    else {
                        if (emitter) {
                            switch (arguments.length) {
                                case 0:
                                case 1:
                                    emitter.emit("success");
                                    emitter.emit("finish", null);
                                    break;
                                case 2:
                                    emitter.emit("success", arguments[1]);
                                    emitter.emit("finish", null, arguments[1]);
                                    break;
                                case 3:
                                    emitter.emit("success", arguments[1], arguments[2]);
                                    emitter.emit("finish", null, arguments[1], arguments[2]);
                                    break;
                                default:
                                    arguments[0] = "success";
                                    emitter.emit.apply(task, arguments);
                                    if (EventEmitter.listenerCount(task, "finish") > 0) {
                                        arguments[0] = "finish";
                                        Array.prototype.splice.call(arguments, 1, 0, null);
                                        emitter.emit.apply(task, arguments);
                                    }
                                    break;
                            }
                        }
                        resolve(arguments[1]);
                    }
                }
                catch (err) {
                    this.emit("error", err);
                }
            }
        }
    };
    return FilesystemPlus;
})(EventEmitter);
exports.FilesystemPlus = FilesystemPlus;
