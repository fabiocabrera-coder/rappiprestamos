var WebSocket = require("ws");
var Url = require("url");
var WebSocketChannelFactory = (function () {
    function WebSocketChannelFactory() {
    }
    WebSocketChannelFactory.prototype.connect = function (address, options, callback) {
        options = options || {};
        // #if NODE
        var url = Url.parse(address);
        options.username = url.auth || options.username;
        options.password = options.password || options.passphrase;
        url.auth = null;
        address = Url.format(url);
        // #endif
        this._connect(address, options, null, callback); // WEB: // removed
    }; // WEB: // removed
    WebSocketChannelFactory.prototype._connect = function (address, options, credentials, callback) {
        var _this = this;
        // #if NODE
        var username = options.username;
        var password = options.password;
        if (username && password) {
            credentials = getBasicAuthHeader(username, password);
        }
        if (credentials != null) {
            options.headers = options.headers || {};
            options.headers["Authorization"] = credentials;
        }
        var authenticate = null;
        // #endif
        //WEB: var protocols;
        //WEB: if (options.protocol) protocols = [options.protocol];
        var ws = new WebSocket(address, options); //WEB: var ws = new WebSocket(address, protocols);
        //WEB: ws.binaryType = "arraybuffer";
        var channel = new WebSocketChannel(ws, false);
        ws.on("open", function () {
            channel._init();
            callback(null, channel);
        }); //WEB: };
        // #if NODE
        ws.on("unexpected-response", function (req, res) {
            var msg = req;
            // abort the request
            req.abort();
            var information = res.headers["sftp-authenticate-info"];
            var message;
            var code = "X_NOWS";
            switch (res.statusCode) {
                case 200:
                    message = "Unable to upgrade to WebSocket protocol";
                    break;
                case 401:
                    if (credentials == null) {
                        for (var i = 0; i < res.rawHeaders.length; i += 2) {
                            if (!res.rawHeaders[i].match(/^WWW-Authenticate$/i))
                                continue;
                            if (!res.rawHeaders[i + 1].match(/^Basic realm/))
                                continue;
                            authenticate = "Basic";
                            break;
                        }
                        message = "Authentication required";
                    }
                    else {
                        message = "Authentication failed";
                    }
                    code = "X_NOAUTH";
                    break;
                default:
                    message = "Unexpected server response: '" + res.statusCode + " " + res.statusMessage + "'";
                    break;
            }
            var err = new Error(message);
            err.code = err.errno = code;
            err.level = "http";
            if (information)
                err.info = information;
            channel._close(2, err);
        });
        function getBasicAuthHeader(username, password) {
            return "Basic " + new Buffer(username + ":" + password).toString("base64");
        }
        // #endif
        channel.on("close", function (err) {
            err = err || new Error("Connection closed");
            // #if NODE
            if (err.code === "X_NOAUTH" && authenticate && typeof (options.authenticate) === "function") {
                // prepare queries
                var queries = [];
                if (!username)
                    queries.push({ name: "username", prompt: "Username:", secret: false });
                queries.push({ name: "password", prompt: "Password:", secret: true });
                var instructions = err.info;
                var self = _this;
                // invoke client authentication callback
                var auth = options.authenticate;
                if (auth.length >= 3) {
                    return auth(instructions, queries, supply);
                }
                else {
                    var result = auth(instructions, queries);
                    return supply(result);
                }
                function supply(values) {
                    values = values || {};
                    if (!username)
                        username = values["username"];
                    password = values["password"];
                    if (username && password) {
                        // try authenticating with the supplied credentials
                        credentials = getBasicAuthHeader(username, password);
                        options.username = null;
                        options.password = null;
                        self._connect(address, options, credentials, callback);
                    }
                    else {
                        // fail if no credentials supplied
                        callback(err, null);
                    }
                }
            }
            // #endif
            callback(err, null);
        });
    };
    // #if NODE
    WebSocketChannelFactory.prototype.bind = function (ws) {
        if (ws.readyState != WebSocket.OPEN)
            throw new Error("WebSocket is not open");
        return new WebSocketChannel(ws, true);
    };
    return WebSocketChannelFactory;
})();
exports.WebSocketChannelFactory = WebSocketChannelFactory;
var WebSocketChannel = (function () {
    function WebSocketChannel(ws, established) {
        var _this = this;
        this.ws = ws;
        this.options = { binary: true }; //WEB: // removed
        this.established = established;
        //WEB: this.failed = false;
        ws.on("close", function (reason, description) {
            //WEB: var reason = e.code;
            //WEB: var description = e.reason;
            var message = "Connection failed";
            var code = "EFAILURE";
            switch (reason) {
                case 1000:
                    return _this._close(reason, null);
                case 1001:
                    message = "Endpoint is going away";
                    code = "X_GOINGAWAY";
                    break;
                case 1002:
                    message = "Protocol error";
                    code = "EPROTOTYPE";
                    break;
                case 1006:
                    //WEB: if (this.failed) {
                    //WEB:     message = "Connection refused";
                    //WEB:     code = "ECONNREFUSED";
                    //WEB:     break;
                    //WEB: }
                    message = "Connection aborted";
                    code = "ECONNABORTED";
                    break;
                case 1007:
                    message = "Invalid message";
                    break;
                case 1008:
                    message = "Prohibited message";
                    break;
                case 1009:
                    message = "Message too large";
                    break;
                case 1010:
                    message = "Connection terminated";
                    code = "ECONNRESET";
                    break;
                case 1011:
                    message = description; //WEB: message = "Connection reset";
                    code = "ECONNRESET";
                    break;
                case 1015:
                    message = "Unable to negotiate secure connection";
                    break;
            }
            var err = new Error(message);
            err.code = err.errno = code;
            err.level = "ws";
            err.nativeCode = reason;
            _this._close(reason, err);
        }); //WEB: };
        ws.on("error", function (err) {
            //WEB: this.failed = true;
            // #if NODE
            var message = err.message;
            var code = err.code;
            switch (code) {
                case "HPE_INVALID_CONSTANT":
                    err.message = "Server uses invalid protocol";
                    err.level = "http";
                    break;
                case "UNABLE_TO_VERIFY_LEAF_SIGNATURE":
                    err.message = "Unable to verify leaf certificate (possibly due to missing intermediate CA certificate)";
                    err.level = "ssl";
                    break;
            }
            if (typeof err.code !== "undefined" && typeof err.errno === "undefined")
                err.errno = code;
            _this._close(0, err);
            // #endif
        }); //WEB: };
    }
    WebSocketChannel.prototype.on = function (event, listener) {
        if (typeof listener !== "function")
            throw new Error("Listener must be a function");
        switch (event) {
            case "message":
                this.onmessage(listener);
                break;
            case "close":
                this.onclose = listener;
                break;
            default:
                break;
        }
        return this;
    };
    WebSocketChannel.prototype.onmessage = function (listener) {
        var _this = this;
        this.ws.on("message", function (data, flags) {
            if (_this.closed)
                return;
            var packet;
            if (flags.binary) {
                packet = data; //WEB: packet = new Uint8Array(message.data);
            }
            else {
                var err = new Error("Connection failed due to unsupported packet type");
                err.code = err.errno = "EFAILURE";
                err.level = "ws";
                _this._close(1, err);
                return;
            }
            listener(packet);
        }); //WEB: };
    };
    WebSocketChannel.prototype._init = function () {
        this.onclose = null;
        this.established = true;
    };
    WebSocketChannel.prototype._close = function (kind, err) {
        if (this.closed)
            return;
        var onclose = this.onclose;
        this.close();
        if (!err && !this.established) {
            err = new Error("Connection refused");
            err.code = err.errno = "ECONNREFUSED";
        }
        if (typeof onclose === "function") {
            process.nextTick(function () { return onclose(err); });
        }
        else {
            if (err)
                throw err;
        }
    };
    WebSocketChannel.prototype.close = function (reason, description) {
        if (this.closed)
            return;
        this.closed = true;
        this.onclose = null;
        this.onmessage = null;
        if (!reason)
            reason = 1000;
        try {
            this.ws.close(reason, description);
        }
        catch (err) {
        }
    };
    WebSocketChannel.prototype.send = function (packet) {
        var _this = this;
        if (this.closed)
            return;
        try {
            this.ws.send(packet, this.options, function (err) {
                if (err)
                    _this._close(3, err); //WEB: // removed
            }); //WEB: // removed
        }
        catch (err) {
            this._close(2, err);
        }
    };
    return WebSocketChannel;
})();
