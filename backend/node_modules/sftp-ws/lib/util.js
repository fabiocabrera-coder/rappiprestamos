var util = require("util");
var LogHelper = (function () {
    function LogHelper() {
    }
    LogHelper.getLevel = function (log) {
        var value = log.level();
        if (typeof value === "number")
            return value;
        switch (("" + value).toLowerCase()) {
            case "trace": return 10;
            case "debug": return 20;
            case "info": return 30;
            case "warn": return 40;
            case "error": return 50;
            case "fatal": return 60;
        }
        var level = value | 0;
        if (level <= 0 || level >= 100)
            level = 60;
        return level;
    };
    LogHelper.isTrace = function (log) {
        var level = log.level();
        return (level <= 10 || level === "trace");
    };
    LogHelper.toLogWriter = function (writer) {
        function check(names) {
            if (typeof writer !== "object")
                return false;
            for (var i = 0; i < names.length; i++) {
                if (typeof writer[names[i]] !== "function")
                    return false;
            }
            return true;
        }
        ;
        var levels = ["trace", "debug", "info", "warn", "error", "fatal"];
        if (writer == null || typeof writer === "undefined") {
            // no writer specified, create a dummy writer
            var proxy = new Object();
            levels.forEach(function (level) {
                proxy[level] = function (obj, format) {
                    var params = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        params[_i - 2] = arguments[_i];
                    }
                };
            });
            proxy["level"] = function () { return 90; };
            return proxy;
        }
        if (check(levels)) {
            // looks like bunyan, great!
            return writer;
        }
        // #if NODE
        if (check(["log", "debug", "info", "warn", "error", "query"])) {
            // looks like winston, lets's create a proxy for it
            var proxy = new Object();
            levels.forEach(function (level) {
                proxy[level] = function (obj, format) {
                    var params = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        params[_i - 2] = arguments[_i];
                    }
                    // log(level: string, msg: string, meta: any, callback ?: (err: Error, level: string, msg: string, meta: any) => void): LoggerInstance;
                    if (typeof obj === "string") {
                        var msg = util.format(obj, format, params);
                        writer.log(level, msg);
                    }
                    else {
                        var msg = util.format(format, params);
                        writer.log(level, msg, obj);
                    }
                };
            });
            proxy["level"] = function () { return writer.level; };
            return proxy;
        }
        // #endif
        if (check(["log", "info", "warn", "error", "dir"])) {
            // looks like console, lets's create a proxy for it
            var proxy = new Object();
            var console = writer;
            var levelObj;
            var levelNum = 20 /* DEBUG */;
            var funcs = ["log", "log", "info", "warn", "error", "error"];
            var names = ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL"];
            [10, 20, 30, 40, 50, 60].forEach(function (level) {
                var index = level / 10 - 1;
                proxy[levels[index]] = function (obj, format) {
                    var params = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        params[_i - 2] = arguments[_i];
                    }
                    // update current level if needed
                    if (levelObj !== console.level) {
                        levelObj = console.level;
                        levelNum = LogHelper.getLevel(proxy);
                    }
                    // don't log if the logger log level is too high
                    if (level < levelNum)
                        return;
                    // convert to actual console "log levels"
                    var func = funcs[index];
                    var array = params;
                    if (typeof format !== "undefined")
                        array.unshift(format);
                    if (typeof obj === "string" || obj === null) {
                        array.unshift(obj);
                        obj = null;
                    }
                    array = [names[index] + ":", util.format.apply(util, array)]; // WEB: array.push("(" + names[index] + ")");
                    console[func].apply(console, array);
                    if (obj !== null)
                        console[func].call(console, obj);
                };
            });
            proxy["level"] = function () { return console.level || 20 /* DEBUG */; };
            return proxy;
        }
        throw new TypeError("Unsupported log writer");
    };
    return LogHelper;
})();
exports.LogHelper = LogHelper;
var Options = (function () {
    function Options(options) {
        if (!options)
            return;
        for (var propertyName in options) {
            if (options.hasOwnProperty(propertyName))
                this[propertyName] = options[propertyName];
        }
    }
    Options.prototype.merge = function (options) {
        var result = {};
        for (var propertyName in this) {
            if (this.hasOwnProperty(propertyName))
                result[propertyName] = this[propertyName];
        }
        if (options)
            for (var propertyName in options) {
                if (options.hasOwnProperty(propertyName))
                    result[propertyName] = options[propertyName];
            }
        return result;
    };
    Options.prototype.intersect = function (options) {
        var result = {};
        for (var propertyName in this) {
            if (!this.hasOwnProperty(propertyName))
                continue;
            if (options && options.hasOwnProperty(propertyName)) {
                result[propertyName] = options[propertyName];
            }
            else {
                result[propertyName] = this[propertyName];
            }
        }
        return result;
    };
    return Options;
})();
exports.Options = Options;
