var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var WebSocket = require("ws");
var http = require("http");
var path = require("path");
var events = require("events");
var client = require("./sftp-client");
var server = require("./sftp-server");
var safe = require("./fs-safe");
var local = require("./fs-local");
var plus = require("./fs-plus");
var misc = require("./fs-misc");
var channel_ws = require("./channel-ws");
var channel_stream = require("./channel-stream");
var util = require("./util");
var SafeFilesystem = safe.SafeFilesystem;
var WebSocketServer = WebSocket.Server;
var WebSocketChannelFactory = channel_ws.WebSocketChannelFactory;
var SftpServerSession = server.SftpServerSession;
var FileUtil = misc.FileUtil;
var Options = util.Options;
var SftpClient = client.SftpClient;
// #if NODE
var SFTP;
(function (SFTP) {
    var Client = (function (_super) {
        __extends(Client, _super);
        function Client() {
            var localFs = new local.LocalFilesystem(); // WEB: // removed
            _super.call(this, localFs); // WEB: super(null);
        }
        Client.prototype.on = function (event, listener) {
            return _super.prototype.on.call(this, event, listener);
        };
        Client.prototype.once = function (event, listener) {
            return _super.prototype.on.call(this, event, listener);
        };
        Client.prototype.connect = function (address, options, callback) {
            var _this = this;
            if (typeof callback === "undefined" && typeof options === "function") {
                callback = options;
                options = null;
            }
            return _super.prototype._task.call(this, callback, function (callback) {
                options = options || {};
                if (typeof options.protocol == 'undefined') {
                    options.protocol = 'sftp';
                }
                _this._promise = options.promise;
                var factory = new WebSocketChannelFactory();
                factory.connect(address, options, function (err, channel) {
                    if (err)
                        return callback(err);
                    _super.prototype._bind.call(_this, channel, options, callback);
                });
            });
        };
        return Client;
    })(SftpClient);
    SFTP.Client = Client;
    // #if NODE
    var Local = (function (_super) {
        __extends(Local, _super);
        function Local() {
            var fs = new local.LocalFilesystem();
            _super.call(this, fs, null);
        }
        return Local;
    })(plus.FilesystemPlus);
    SFTP.Local = Local;
    SFTP.LocalFilesystem = local.LocalFilesystem;
    var Internals;
    (function (Internals) {
        Internals.StreamChannel = channel_stream.StreamChannel;
        Internals.WebSocketChannelFactory = channel_ws.WebSocketChannelFactory;
        Internals.LogHelper = util.LogHelper;
    })(Internals = SFTP.Internals || (SFTP.Internals = {}));
    var RequestInfo = (function () {
        function RequestInfo() {
        }
        return RequestInfo;
    })();
    SFTP.RequestInfo = RequestInfo;
    var Server = (function (_super) {
        __extends(Server, _super);
        function Server(options) {
            var _this = this;
            _super.call(this);
            options = options || {};
            var serverOptions = {};
            var virtualRoot = options.virtualRoot;
            var filesystem = options.filesystem;
            this._log = util.LogHelper.toLogWriter(options.log);
            this._verifyClient = options.verifyClient;
            var noServer = options.noServer;
            serverOptions.handleProtocols = this.handleProtocols;
            serverOptions.verifyClient = (function (info, callback) {
                _this.verifyClient(info, callback);
            });
            for (var option in options) {
                if (options.hasOwnProperty(option)) {
                    switch (option) {
                        case "filesystem":
                        case "virtualRoot":
                        case "readOnly":
                        case "hideUidGid":
                        case "log":
                        case "verifyClient":
                            break;
                        default:
                            serverOptions[option] = options[option];
                            break;
                    }
                }
            }
            if (typeof virtualRoot === 'undefined') {
                // TODO: serve a dummy filesystem in this case to prevent revealing any files accidently
                virtualRoot = process.cwd();
            }
            else {
                virtualRoot = path.resolve(virtualRoot);
            }
            if (typeof filesystem === 'undefined') {
                filesystem = new local.LocalFilesystem();
            }
            this._sessionInfo = new Options({
                userName: null,
                filesystem: filesystem,
                virtualRoot: virtualRoot,
                readOnly: true && options.readOnly,
                hideUidGid: true && options.hideUidGid
            });
            //TODO: when no _fs and no _virtualRoot is specified, serve a dummy filesystem as well
            if (!noServer) {
                this._wss = new WebSocketServer(serverOptions);
                this._wss.on('connection', function (ws) { return _this.accept(ws, function (err, session) {
                    if (err)
                        _this._log.fatal(err, "Error while accepting connection");
                }); });
                this._log.info("SFTP server started");
            }
        }
        Server.prototype.verifyClient = function (info, accept) {
            var _this = this;
            var con = info.req.connection;
            var level = this._log.level();
            if (level <= 10 || level === "trace") {
                this._log.trace({
                    secure: info.secure,
                    origin: info.origin || null,
                    clientAddress: con.remoteAddress,
                    clientPort: con.remotePort
                }, "Incoming connection from %s:%d", con.remoteAddress, con.remotePort);
            }
            var innerVerify = this._verifyClient;
            var outerAccept = function (result, code, description, headers) {
                if (!result) {
                    if (code < 200 || code > 599)
                        code = 500;
                    if (typeof code === 'undefined')
                        code = 401;
                    if (typeof description === 'undefined')
                        description = http.STATUS_CODES[code];
                    _this._log.debug("Rejected connection from %s:%d (%d %s)", con.remoteAddress, con.remotePort, code, description);
                    if (typeof headers !== 'undefined')
                        description += "\r\n" + headers.join("\r\n");
                    accept(false, code, description);
                    return;
                }
                _this._log.debug("Accepted connection from %s:%d", con.remoteAddress, con.remotePort);
                if (typeof result == 'object')
                    info.req._sftpSessionInfo = result;
                accept(true);
            };
            if (typeof innerVerify !== 'function') {
                return outerAccept(true);
            }
            else if (innerVerify.length >= 2) {
                innerVerify(info, outerAccept);
            }
            else {
                var result = innerVerify(info);
                outerAccept(result);
            }
        };
        Server.prototype.handleProtocols = function (protocols, callback) {
            for (var i = 0; i < protocols.length; i++) {
                var protocol = protocols[i];
                switch (protocol) {
                    case "sftp":
                        callback(true, protocol);
                        return;
                }
            }
            ;
            callback(false);
        };
        Server.prototype.end = function () {
            if (typeof this._wss === 'object') {
                var count = this._wss.clients.length;
                if (count > 0) {
                    this._log.debug("Stopping %d SFTP sessions ...", count);
                    // end all active sessions
                    this._wss.clients.forEach(function (ws) {
                        var session = ws.session;
                        if (typeof session === 'object') {
                            session.end();
                            delete ws.session;
                        }
                    });
                }
                // stop accepting connections
                this._wss.close();
                this._log.info("SFTP server stopped");
            }
        };
        Server.prototype.accept = function (ws, callback) {
            var _this = this;
            try {
                //this._log.debug(ws.upgradeReq);
                // retrieve session info passed to verifyClient's accept callback
                var sessionInfo = ws.upgradeReq._sftpSessionInfo;
                // merge session info with default session info
                sessionInfo = this._sessionInfo.intersect(sessionInfo);
                var log = this._log;
                var virtualRoot = sessionInfo.virtualRoot;
                var fs = new SafeFilesystem(sessionInfo.filesystem, virtualRoot, sessionInfo);
                fs.stat(".", function (err, attrs) {
                    try {
                        if (!err && !FileUtil.isDirectory(attrs))
                            err = new Error("Not a directory");
                        if (err) {
                            var message = "Unable to access file system";
                            log.error({ root: virtualRoot }, message);
                            ws.close(1011 /* UNEXPECTED_CONDITION */, message);
                            callback(err, null);
                            return;
                        }
                        var factory = new WebSocketChannelFactory();
                        var channel = factory.bind(ws);
                        var socket = ws.upgradeReq.connection;
                        var info = {
                            "userName": sessionInfo.userName,
                            "clientAddress": socket.remoteAddress,
                            "clientPort": socket.remotePort,
                            "clientFamily": socket.remoteFamily,
                            "serverAddress": socket.localAddress,
                            "serverPort": socket.localPort
                        };
                        var session = new SftpServerSession(channel, fs, _this, log, info);
                        _this.emit("startedSession", _this);
                        ws.session = session;
                    }
                    catch (err) {
                        callback(err, null);
                    }
                });
            }
            catch (err) {
                process.nextTick(function () { return callback(err, null); });
            }
        };
        return Server;
    })(events.EventEmitter);
    SFTP.Server = Server;
})(SFTP || (SFTP = {}));
module.exports = SFTP;
