var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var readline = require("readline");
var util = require("util");
var argler = require("argler");
var minimist = require("minimist");
var undefined;
// MiniConsole is a wrapper around readline
var MiniConsole = (function () {
    function MiniConsole(input, output) {
        //super();
        this._input = input || process.stdin;
        this._output = output || process.stdout;
        this._readline = null;
        this._callback = null;
        this._keypress = null;
        this._state = 0 /* None */;
        // determine whether we have a TTY
        this._isTTY = (typeof this._input.setRawMode === "function") && this._output.isTTY;
    }
    // initializes readline lazily
    MiniConsole.prototype._init = function () {
        var _this = this;
        if (this._state == 4 /* Closed */)
            throw new Error("Already closed");
        if (this._state != 0 /* None */)
            return;
        this._state = 1 /* Idle */;
        var readlineOptions = {
            input: this._input,
            output: this._output
        };
        // get list of keypress event listeners on input stream
        var keypressListeners = this._input.listeners("keypress");
        // create readline instance and register close event handler
        this._readline = readline.createInterface(readlineOptions);
        this._readline.once("close", function () { return _this._terminate(); });
        // remove and keep keypress listeners on input stream that were set up by readline 
        // (we will call them ourselves)
        var newKeypressListeners = this._input.listeners("keypress");
        var listeners = [];
        for (var i = keypressListeners.length; i < newKeypressListeners.length; i++) {
            var listener = newKeypressListeners[i];
            this._input.removeListener("keypress", listener);
            listeners.push(listener);
        }
        // set up a custom keypress handler
        this._input.on("keypress", function (s, key) {
            if (key && key.ctrl && !key.shift) {
                switch (key.name) {
                    case 'd':
                        break;
                    case 'c':
                        //if (this.emit('SIGINT')) return;
                        _this._terminate();
                        return;
                    case 'z':
                        if (process.platform == 'win32')
                            return;
                        //if (this.emit('SIGTSTP')) return;
                        var input = _this._input;
                        process.once('SIGCONT', function () {
                            //this.emit("SIGCONT");
                            input.resume();
                            input.setRawMode(true);
                        });
                        input.pause();
                        input.setRawMode(false);
                        process.kill(process.pid, 'SIGTSTP');
                        return;
                }
            }
            // pass the event args to custom keypress handler
            if (typeof _this._keypress === "function") {
                _this._keypress(s, key);
            }
            // pass the event args to readline's listeners
            if (_this._state == 2 /* Prompt */) {
                listeners.forEach(function (listener) { return listener.call(null, s, key); });
            }
        });
    };
    // prepare the for an async function
    MiniConsole.prototype._prepare = function (callback) {
        if (typeof callback !== "function")
            throw new TypeError("Callback must be a function");
        if (this._callback)
            throw new Error("Already prompting");
        this._callback = callback;
        this._init();
    };
    // terminates the process
    MiniConsole.prototype._terminate = function () {
        this._callback = null;
        this._state = 4 /* Closed */;
        this._output.write("\n");
        //if (this.emit("close")) return;
        process.exit(128 + 2);
    };
    // asks a question and calls the supplied function when it is answered
    MiniConsole.prototype.question = function (prompt, options, callback) {
        if (typeof prompt !== "string" && !(prompt instanceof String)) {
            throw new TypeError("Prompt must be a string");
        }
        if (callback === undefined && typeof options === "function") {
            callback = options;
            options = undefined;
        }
        options = options || {};
        prompt = "" + prompt;
        if (prompt.length > 0 && !options.noSpace)
            prompt += " ";
        this._prepare(callback);
        this._text(prompt, options);
    };
    // asks for a password and calls the supplied function when done
    MiniConsole.prototype.password = function (prompt, options, callback) {
        if (typeof prompt !== "string" && !(prompt instanceof String)) {
            throw new TypeError("Prompt must be a string");
        }
        if (callback === undefined && typeof options === "function") {
            callback = options;
            options = undefined;
        }
        prompt = "" + prompt;
        options = options || {};
        this._prepare(callback);
        this._password(prompt, options);
    };
    // starts prompting for a text
    MiniConsole.prototype._text = function (prompt, options) {
        var _this = this;
        this._readline.once("line", function (line) {
            var cb = _this._callback;
            _this._callback = null;
            _this._state = 1 /* Idle */;
            if (cb)
                process.nextTick(function () { return cb(line); });
        });
        this._readline.setPrompt(prompt);
        var preserveCursor = false;
        this._state = 2 /* Prompt */;
        this._readline.prompt(preserveCursor);
    };
    // prompts for a password
    MiniConsole.prototype._password = function (prompt, options) {
        if (!this._isTTY)
            throw new Error("Secret text prompt only supported on TTY streams");
        var passwordChar = "" + options.passwordChar;
        var silent = false;
        if (passwordChar.length == 0) {
            silent = true;
        }
        else {
            passwordChar = passwordChar[0];
        }
        var input = this._input;
        var output = this._output;
        var password = "";
        var self = this;
        // use custom keypress handling instead of readline's
        this._state = 3 /* Custom */;
        this._keypress = keypress;
        // display prompt if specified
        if (prompt.length > 0) {
            if (!options.noSpace)
                prompt += " ";
            output.write(prompt);
        }
        // callback proxy
        function callback(password) {
            var cb = self._callback;
            if (!cb)
                return;
            self._callback = null;
            process.nextTick(function () { return cb(password); });
        }
        ;
        // resume normal behavior
        function finish() {
            self._state = 1 /* Idle */;
            self._keypress = null;
        }
        // custom keypress handler
        function keypress(s, key) {
            var name;
            if (typeof key !== "undefined") {
                name = key.name;
                if (key.ctrl && !key.shift) {
                    switch (name) {
                        case 'c':
                            finish();
                            return;
                        case 'd':
                            if (password.length == 0) {
                                finish();
                            }
                            return;
                        case 'h':
                            key = { name: "backspace" };
                            break;
                        default:
                            return;
                    }
                }
                if (key.meta || key.ctrl)
                    return;
            }
            switch (name) {
                case 'return': // CR
                case 'enter':
                    finish();
                    output.write("\r\n");
                    callback(password);
                    break;
                case 'backspace':
                    if (password.length > 0) {
                        password = password.substring(0, password.length - 1);
                        if (!silent)
                            output.write("\u0008 \u0008");
                    }
                    break;
                default:
                    if (typeof s === "string") {
                        var c = s[0];
                        if (c.charCodeAt(0) >= 0x20) {
                            if (!silent)
                                output.write('*');
                            password += c;
                        }
                    }
                    break;
            }
        }
    };
    // writes a message to output
    MiniConsole.prototype.write = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        message = util.format.apply(this, arguments) + '\n';
        this._output.write(message);
    };
    // closes the console
    MiniConsole.prototype.close = function () {
        this._state = 4 /* Closed */;
        if (this._readline)
            this._readline.close();
    };
    return MiniConsole;
})();
// provides command context and context-specific functions
var CommandContext = (function () {
    function CommandContext(shell, command, args, options) {
        this._shell = shell;
        this.command = command;
        this.args = args;
        this.options = options;
    }
    // execute another command with the specified arguments (unparsed)
    CommandContext.prototype.execute = function (command) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._shell)
            return;
        var shell = this._shell;
        this._shell = null;
        command = "" + command;
        if (!args)
            args = [];
        shell._execute(command, args);
    };
    // writes a message to output
    CommandContext.prototype.write = function (message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (!this._shell)
            return;
        this._shell.write.apply(this._shell, arguments);
    };
    // displays help
    CommandContext.prototype.help = function () {
        if (!this._shell)
            return;
        var shell = this._shell;
        shell._help();
    };
    // ends the current command, making the shell prompt for another
    CommandContext.prototype.end = function () {
        if (!this._shell)
            return;
        var shell = this._shell;
        this._shell = null;
        shell._next();
    };
    CommandContext.prototype.fail = function (err) {
        if (err.message)
            err = err.message;
        err = "" + err;
        this.write(err);
        this.end();
    };
    return CommandContext;
})();
// provides shell capabilities on top of MiniConsole
var MiniShell = (function (_super) {
    __extends(MiniShell, _super);
    function MiniShell(input, output) {
        _super.call(this, input, output);
        this._commands = {};
        this._prompt = "> ";
    }
    MiniShell.prototype.command = function (command, help, action) {
        var _this = this;
        if (action === undefined) {
            if (typeof help === "function") {
                action = help;
                help = null;
            }
            else {
                action = null;
            }
        }
        else if (typeof action !== "function") {
            throw new TypeError("Function must be a function");
        }
        if (!Array.isArray(command))
            command = [command];
        command.forEach(function (command) {
            if (!command) {
                command = "";
            }
            else {
                command = "" + command;
            }
            if (command.length == 0)
                throw new Error("Empty command");
            _this._commands[command] = action;
            if (help && command !== "_")
                action.help = help;
        });
        return this;
    };
    // sets the prompt and starts prompting for a command
    MiniShell.prototype.prompt = function (prompt, options) {
        options = options || {};
        this._arglerOptions = {
            ignoreBackslash: options.ignoreBackslash
        };
        this._command;
        this._prompt = "" + (prompt || "> ");
        this._next();
    };
    // starts prompting for a command
    MiniShell.prototype._next = function () {
        var _this = this;
        _super.prototype.question.call(this, this._prompt, { noSpace: true }, function (line) { return _this._command(line); });
    };
    // runs the specified command line
    MiniShell.prototype._command = function (line) {
        // parse line into command and arguments using argler
        var args = argler(line, this._arglerOptions);
        var cmd = args.shift();
        this._execute(cmd, args);
    };
    // executes the specified command with unparsed arguments
    MiniShell.prototype._execute = function (cmd, args) {
        // parse arguments using minimist
        var options = minimist(args, { string: ['_'] });
        args = options._;
        if (args !== undefined)
            delete options._;
        // if the command was empty, prompt again
        if (!cmd || cmd.length == 0)
            return this._next();
        // run the command and/or report an error
        var action = this._commands[cmd];
        // all action-less commands map to "_" command
        if (action === null)
            action = this._commands["_"];
        if (typeof action === "function") {
            try {
                action.call(null, new CommandContext(this, cmd, args, options));
            }
            catch (err) {
                //TODO: add a configurable event handler
                _super.prototype.write.call(this, "Error:", err.message);
                this._next();
            }
        }
        else if (cmd == "help") {
            this._help();
            this._next();
        }
        else {
            _super.prototype.write.call(this, "Command '%s' not supported.", cmd);
            this._next();
        }
    };
    // displays help
    MiniShell.prototype._help = function () {
        var _this = this;
        var help = [];
        var padding = "";
        for (var command in this._commands) {
            if (command === "_")
                continue;
            if (!this._commands.hasOwnProperty(command))
                continue;
            help.push(command);
            while (padding.length <= command.length)
                padding += " ";
        }
        help.sort();
        help.forEach(function (command) {
            var h = _this._commands[command].help || "";
            _super.prototype.write.call(_this, "%s %s%s", command, padding.slice(command.length - padding.length), h);
        });
    };
    return MiniShell;
})(MiniConsole);
// create a new instance of IMiniShell
function create(input, output) {
    return new MiniShell(input, output);
}
// exits the whole process with an optional exit code
function exit(code) {
    process.exit(code);
}
// create an instance of IMiniShell and export it
var minish = new MiniShell();
minish.parse = minimist;
minish.create = create;
minish.exit = exit;
module.exports = minish;
